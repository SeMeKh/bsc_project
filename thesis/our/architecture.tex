\قسمت{معماری}
آزمودن برنامه راهی برای افزایش کیفیت نرم‌افزار است. پیش از این رویکردهایی در توسعه‌ی \واژه{تست}های نرم‌افزاری را دیدیم. با ایده گرفتن از نقاط قوّت آن‌ها و در تلاش برای یافتن راهکاری برای ضعف‌های آن‌ها، معماری جدیدی را جهت انجام \واژه{تست} ارائه می‌کنیم.

از نظر ما این معماری یک روش جدید نیست، بلکه تکمیل‌کننده‌ی روش رفتاررانه است. بدین معنا که \واژه{بی.دی.دی.} اهداف کلّی و وضعیت مطلوب را توصیف می‌کند؛ حال آن که معماری پیشنهادی ما تلاش می‌کند تا ساختاری مناسب جهت دست‌یابی به این وضعیت را فراهم کند.

در بخش \رجوع{gwt} با نحوه‌ی بیان یک \واژه{سناریو} آشنا شدیم. این بیان به زبان ریاضی به شکل زیر است:

\شروع{equation}
\برچسب{eq:gIwIt}
g \implies (w \implies t)
\پایان{equation}


نکته‌ی قابل تأمّل آن که عبارت \رجوع{eq:gIwIt} و $g \land w \implies t$ معادلند. حال آن که این دو بخش از منظر معنایی تفاوت محسوسی دارند. مادامی که $g$ ؟؟؟؟


یک سناریو، در واقع پاسخ صحیح یک زیرمسأله از مسأله‌ی اصلی را بیان می‌کند. با معماری پیشنهادی ما، 

معماری پیشنهادی، حول ایده‌ی جداسازی \واژه{سناریو}ها از مصادیق صحّت‌سنجی آن صورت گرفته. در این معماری، \واژه{سناریو}هایی توسّط برنامه‌نویس تعبیه می‌شود که مطابق تعریف، انتظار می‌رود همواره برقرار باشند. مجموعه‌ی این \واژه{سناریو}ها یک 

همچنین، 

با توجّه به تعریف، خود \واژه{سناریو}ها تنها مجموعه‌ای از گزاره‌ها هستند. حال آن که سنجش صحّت این گزاره‌ها می‌تواند \واژه{متریک} خوبی برای کیفیّت کد باشد. لایه‌ی سوم معماری، لایه‌ای است که موجبات trigger شدن این \واژه{سناریو}ها را فراهم می‌کند. به عبارتی، این لایه موظّف است شرایط متنوّعی را فراهم آورد که شروط $given$ سناریوهای متفاوت برقرار شود

به این ترتیب، 

تفاوت معنایی: 


در زیر نمونه‌ای از شبه‌کد آزمون 

